## TIW8 - TP3 Collaboration temps-r√©el 

#### Encadrants
- Aur√©lien Tabard (responsable)
- Lionel M√©dini
- Alix Ducros



### TP3.2 Visio p2p avec serveur

#### Class properties

Les `function components` sont utiles pour se forcer √† ne pas g√©rer l'√©tat dans ses composants de pr√©sentation.

Au court du TP nous allons utiliser des `Class components` pour g√©rer les routines de d√©couverte et connexion li√©es √† WebRTC qui elles vont devoir maintenir des √©tats complexes. Pour cela nous allons utiliser les [`class properties` dans nos composants React](https://codeburst.io/use-class-properties-to-clean-up-your-classes-and-react-components-93185879f688), voir la documentation des classes

Dans votre fichier babel, rajouter le [plugin-proposal-class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties) :

```js 
{
  "plugins": ["@babel/plugin-proposal-class-properties"]
} 
```

Plus d'information sur les [class fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_fields)
)

#### Mise en place d'un serveur


#### Signaling c√¥t√© serveur

Nous allons utiliser une version l√©g√®rement modifi√©e du [code serveur](https://github.com/mdn/samples-server/blob/master/s/webrtc-from-chat/chatserver.js) de la [documentation MDN](http://bit.ly/webrtc-from-chat)


**TODO donner le code serveur**


#### Signaling c√¥t√© client

Voici une [classe qui permet de g√©rer le signaling c√¥t√© client](../code/SignalingConnection.js).

Elle fait les choses suivantes : 

- cr√©e un WebSocket avec `connectToSocket`,  
- configure des callbacks : `onOpen` quand la connexion d√©marre, `onMessage` quand on recoit des messages.
- `addMsgListener` permet d'ajouter des listeners de message au besoin.  
- `sendToServer` permet d'envoyer un objet json au serveur.

Nous allons utiliser cela pour configurer se connecter √† l'autre client participant √† l'appel. 


### G√©rer plusieurs utilisateurs

Ces imports faits, nous allons maintenant rajouter un module dans l'interface pour g√©rer les noms d'utilisateurs, plut√¥t que de tout g√©rer en dur dans le code.

A la fin du TP, votre application devrait ressembler √† ceci :

![](./skyper2.png)

Faites en sorte qu'√† l'ouverture de la page une instance de `SignalingConnection` soit cr√©√©e. Lors de l'initialisation de l'objet `SignalingConnection`, le serveur sera contact√© et renverra un message contenant l'identifiant unique correspondant au client. G√©rez la r√©ception de ce type de message dans le callback onMessage de `SignalingConnection`

```json
{
    "type":"id",
    "id":1576167442554
}
```

Conservez cet identifiant dans l'√©tat de votre composant.

#### Cr√©er son username

Ajoutez un champ de texte dans votre interface, qui vous permettra d'√©diter l'username sous lequel vous souhaiterez apparaitre. Liez son contenu √† votre √©tat. Ajoutez aussi un bouton qui permet de valider votre username et de le d√©clarer au serveur de la mani√®re suivante :


```js
    const pushUsername = () => {
        this.signalingConnection.sendToServer({
            name: username,
            date: Date.now(),
            id: clientID,
            type: "username"
        });
    };
```

Vous remarquerez la pr√©sence d'un clientID, c'est l'id attribu√© pr√©c√©demment par le serveur. Veillez bien √† ce qu'il ai la bonne valeur.

A chaque fois que le serveur d√©tectera un changement d'username d'un client, il envoie √† tous une liste mise √† jour de tous les utilisateurs qui peuvent √™tre contact√©s. 

```json
{
    "type":"userlist",
    "users":[
        "Nova_Erdma",
        "Bob_Redant"
    ]
}
```

Sauvegardez ces donn√©es et affichez les sous forme de liste permettant de choisir l'utilisateur que vous voulez appeler :

```jsx
<p>{user} <Button onClick={() => {call(user)}} disabled={!callAvailable}>üìû</Button></p>
```


#### Refactoring 
Une grosse partie du code n'a pas sa place dans un composant sens√© g√©r√© la vue.

Nous allons r√©organiser tout cela pour avoir une helper classe qui g√®re la logique de connexion, avant de passer √† la suite.



### Etablissement de la connexion pair √† pair





#### FIN

Vous pouvez maintenant tester, nettoyer le code, et rendre.

## Rendu

√Ä rendre pour le dimanche 15 d√©cembre √† 23h59.

1. D√©ployez votre code sur Heroku
2. Pousser votre code sur la forge
3. D√©poser les liens sur Tomuss "UE-INF2427M Technologies Web Synchrones Et Multi-Dispositifs"

- Le lien vers Heroku pointe vers une page fonctionelle
- Le lien vers la forge permet de faire un clone (format suivant: https://forge.univ-lyon1.fr/xxx/tiw8-tp3.git)

### Crit√®res d'√©valuation

- Fichier `README.md` d√©crivant le process de build en dev, en prod, et de d√©ploiement.
- Fichier `package.json` nettoy√© ne contenant que les d√©pendances n√©cessaires.
- D√©ploiement sur Heroku
- 
- Qualit√© globale du rendu (= application qui ressemble √† quelque chose, un minimum de mise en page, orthographe propre, composants s'appuyant sur des librairies CSS ou styl√©s √† la main).


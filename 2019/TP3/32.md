## TIW8 - TP3 Collaboration temps-r√©el 

#### Encadrants
- Aur√©lien Tabard (responsable)
- Lionel M√©dini
- Alix Ducros



### TP3.2 Visio p2p avec serveur

Le composant `Videochat` va beaucoup changer, plut√¥t que de le faire √©voluer, **cr√©ez en un nouveau** repartant de l'ancien.

Vous pouvez supprimer les r√©f√©rences √† serversRef, client1 et client2, nous allons maintenant g√©rer les connexions de mani√®re g√©n√©rique.

Faire une page d'accueil qui permette de basculer facilement vers un composant ou l'autre (pour la correction).

#### Class properties

Les `function components` sont utiles pour se forcer √† ne pas g√©rer l'√©tat dans ses composants de pr√©sentation.

Au court du TP nous allons utiliser des `Class components` pour g√©rer les routines de d√©couverte et connexion li√©es √† WebRTC qui elles vont devoir maintenir des √©tats complexes. Pour cela nous allons utiliser les [`class properties` dans nos composants React](https://codeburst.io/use-class-properties-to-clean-up-your-classes-and-react-components-93185879f688), voir la documentation des classes

Dans votre fichier babel, rajouter le [plugin-proposal-class-properties](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties) :

```js 
{
  "plugins": ["@babel/plugin-proposal-class-properties"]
} 
```

Plus d'information sur les [class fields](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Class_fields) en ES6.

#### Mise en place d'un serveur

Nous allons utiliser une version l√©g√®rement modifi√©e du [code serveur](https://github.com/mdn/samples-server/blob/master/s/webrtc-from-chat/chatserver.js) de la [documentation MDN sur WebRTC](http://bit.ly/webrtc-from-chat), [t√©l√©chargeable ici](https://gist.github.com/Karalix/e68946d2c58680ec56c55b57c9765daf).


La commande `heroku logs` vous permet de r√©cup√©rer les logs du serveur.

#### Signaling c√¥t√© client

Voici une [classe qui permet de g√©rer le signaling c√¥t√© client](../code/SignalingConnection.js).

Elle fait les choses suivantes : 

- cr√©e un WebSocket avec `connectToSocket`,  
- configure des callbacks : `onOpen` quand la connexion d√©marre, `onMessage` quand on recoit des messages.
- `addMsgListener` permet d'ajouter des listeners de message au besoin.  
- `sendToServer` permet d'envoyer un objet json au serveur.

Nous allons utiliser cela pour orchestrer les clients qui participent √† l'appel. 

Vous pouvez supprimer les fonctions associ√©es √† ICE dans votre composant principal (`onIceStateChange, onIceCandidate, onCreateOfferSuccess, onCreateAnswerSuccess`).


Au lieu d'utiliser un `componentDidMount` nous allons utiliser un `Effect Hook` pour cr√©er la connexion au serveur de signaling au chargement du composant.

```js
    useEffect(() => {
        signalingConnection = new SignalingConnection({
            //socketURL: "localhost:3000",
            socketURL: window.location.hostname,
            onOpen: () => {console.log('signalingConnection open')},
            onMessage: onSignalingMessage
        });
    }, [])
```


Pour des raisons de simplicit√© lors du d√©veloppement d√©clarez `signalingConnection` globalement (√† l'ext√©rieur du function component), vous pourrez refactorer plus tard.


Enfin il faudra construire au fur et √† mesure du TP la fonction qui g√®rera les diff√©rents signaux qui arrivent.
Observer les messages qui arrivent et maintenez un √©tat coh√©rent entre les diff√©rents clients.

```js
    const onSignalingMessage = (msg) => {
        console.log('signaling message : ', msg)

        switch (msg.type) {
        }
    };
```



### G√©rer plusieurs utilisateurs

Ces imports faits, nous allons maintenant rajouter un module dans l'interface pour g√©rer les noms d'utilisateurs, plut√¥t que de tout g√©rer en dur dans le code.

A la fin du TP, votre application devrait ressembler √† ceci :

![](./skyper2.png)

Faites en sorte qu'√† l'ouverture de la page une instance de `SignalingConnection` soit cr√©√©e. Lors de l'initialisation de l'objet `SignalingConnection`, le serveur sera contact√© et renverra un message contenant l'identifiant unique correspondant au client. G√©rez la r√©ception de ce type de message dans le callback onMessage de `SignalingConnection`

```json
{
    "type":"id",
    "id":1576167442554
}
```

Conservez cet identifiant dans l'√©tat de votre composant.

#### Cr√©er son username

Ajoutez un champ de texte dans votre interface, qui vous permettra d'√©diter l'username sous lequel vous souhaiterez apparaitre. Liez son contenu √† votre √©tat. Ajoutez aussi un bouton qui permet de valider votre username et de le d√©clarer au serveur de la mani√®re suivante :


```js
    const pushUsername = () => {
        this.signalingConnection.sendToServer({
            name: username,
            date: Date.now(),
            id: clientID,
            type: "username"
        });
    };
```

Vous remarquerez la pr√©sence d'un clientID, c'est l'id attribu√© pr√©c√©demment par le serveur. Veillez bien √† ce qu'il ai la bonne valeur.

#### Afficher les utilisateurs connect√©s

A chaque fois que le serveur d√©tectera un changement d'username d'un client, il envoie √† tous une liste mise √† jour de tous les utilisateurs qui peuvent √™tre contact√©s. 

```json
{
    "type":"userlist",
    "users":[
        "Nova_Erdma",
        "Bob_Redant"
    ]
}
```

Sauvegardez ces donn√©es et affichez les sous forme de liste permettant de choisir l'utilisateur que vous voulez appeler :

```jsx
<p>{user} <Button onClick={() => {call(user)}} disabled={!callAvailable}>üìû</Button></p>
```



### Etablissement de la connexion pair √† pair

Pour d√©marrer, vous pourrez utiliser la classe [PeerConnection.js](../code/PeerConnection.js) qui se charge de g√©rer les routines li√©es aux connexions.

#### Initialisation de la connexion

En cas d'appel on rajoute le nom de la personne appel√©e comme target, et on initialise une PeerConnection.
```js
    const call = user => {
        targetUsername = user; // ref et non state
        createPeerConnection();
    };

    const createPeerConnection = () => {
        if (peerConnection) return;

        peerConnection = new PeerConnection({
            gotRemoteStream: gotRemoteStream,
            gotRemoteTrack: gotRemoteTrack,
            signalingConnection: signalingConnection,
            onClose: closeVideoCall,
            localStream: localStreamRef.current,
            username: username,
            targetUsername: targetUsername.current
        });
    };
```
Pour des raisons de simplicit√© lors du d√©veloppement d√©clarez `peerConnection` globalement (√† l'ext√©rieur du function component), vous pourrez refactorer plus tard.

Pour pouvoir cr√©er une `PeerConnection` vous aurez besoin de d√©finir un ensemble de fonctions de gestion des flux vid√©os.

```js
    const gotStream = stream => {
        localVideoRef.current.srcObject = stream;
        setCall(true);
        localStreamRef.current = stream;
    };
    const gotRemoteTrack = event => {
        let remoteVideo = remoteVideoRef.current;

        if (remoteVideo.srcObject !== event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
        }

        setHangup(true);
    };
    const gotRemoteStream = event => {
        let remoteVideo = remoteVideoRef.current;

        if (remoteVideo.srcObject !== event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
        }
    };
    
```

V√©rifier que tout les messages de signaling passent bien lors de l'√©tablissement de la connection. 

#### Etablissement de la connexion

Pour pouvoir √©tablir votre connexion, il faudra g√©rer un *Interactive Connectivity Establishment*.

Pour cela il faut g√©rer les demandes de connexion, vous aller recevoir un `new-ice-candidate`, et en r√©action l'ajouter √† votre peerConnection. [En savoir plus](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate)

```js
    case "new-ice-candidate": // A new ICE candidate has been received
        newICECandidate(msg)
        break;
```

```js
    const newICECandidate = ({candidate}) => {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }
```


#### Recevoir l'appel

Dans le cas ou vous recevez l'appel, il faut rajouter la gestion de l'invitation dans votre `onSignalingMessage`

```js 
    case "video-offer": // Invitation and offer to chat
        createPeerConnection();
        peerConnection.videoOffer(msg);
        break;
```


#### Etablir l'appel

Dans la gestion du signaling rajouter la gestion de l'appel.

```js
    case "video-answer": // Callee has answered our offer
        peerConnection.videoAnswer(msg);
        break;
```


#### Raccrocher et clore l'appel

En cas de clic sur le bouton "raccrocher" :

1. Envoyer un message "hang-up" au signaling serveur `signalingConnection.sendToServer{(...)}`
2. Fermer le peerConnection

Pour la personne √† l'autre bout de l'appel, rajouter la gestion du `hang-up` dans le signaling :

```js
    case "hang-up": // The other peer has hung up the call
        close()
        break;
```

On ferme la connexion.
```js
    const close = () => {
        peerConnection.peerConnection.close();
        peerConnection.peerConnection = null;

        closeVideoCall();
    }
```

On ferme le flux vd√©o.
```js
    const closeVideoCall = () => {
        remoteVideoRef.current.srcObject &&
            remoteVideoRef.current.srcObject
                .getTracks()
                .forEach(track => track.stop());
        remoteVideoRef.current.src = null;

        // TODO Mettre √† jour l'√©tat des boutons, et supprimer targetUsername.
    };    
```



### Refactoring 
Une grosse partie du code n'a pas sa place dans un composant sens√© g√©r√© la vue.

R√©organisez tout cela pour avoir une helper class qui g√®re la logique de connexion.



#### FIN

Vous pouvez maintenant tester, nettoyer le code, et le rendre.

## Rendu

√Ä rendre pour le dimanche 15 d√©cembre √† 23h59.

1. D√©ployez votre code sur Heroku
2. Pousser votre code sur la forge
3. D√©poser les liens sur Tomuss "UE-INF2427M Technologies Web Synchrones Et Multi-Dispositifs"

- Le lien vers Heroku pointe vers une page fonctionelle
- Le lien vers la forge permet de faire un clone (format suivant: https://forge.univ-lyon1.fr/xxx/tiw8-tp3.git)


### Crit√®res d'√©valuation

malus si pas fait : 
- Fichier `README.md` d√©crivant le process de build en dev, en prod, et de d√©ploiement.
- Fichier `package.json` nettoy√© ne contenant que les d√©pendances n√©cessaires.
- D√©ploiement sur Heroku

40 % : 
- Visio locale (TP1) 

30 % :
- Partage des noms via le signaling (TP2)

20 % :  
- Visio fonctionelle (TP2 - difficile)

10 % 
- Qualit√© globale du rendu (= application qui ressemble √† quelque chose, un minimum de mise en page, orthographe propre, composants s'appuyant sur des librairies CSS ou styl√©s √† la main).
- Linting
- Respect des principes de programmation React (utilisation des etat et des references, des idiomes, etc.)
